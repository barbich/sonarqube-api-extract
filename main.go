package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"

	"net/http"
	"os"
	"strings"

	"github.com/pb33f/libopenapi"
	base "github.com/pb33f/libopenapi/datamodel/high/base"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
	orderedmap "github.com/pb33f/libopenapi/orderedmap"
	log "github.com/sirupsen/logrus"
)

// Generic struct for sonarqube API calls, based on ingestion the sonarqube API list view output to https://mholt.github.io/json-to-go
type AutoGenerated struct {
	WebServices []struct {
		Path        string `json:"path"`
		Since       string `json:"since,omitempty"`
		Description string `json:"description,omitempty"`
		Actions     []struct {
			Key                string `json:"key"`
			Description        string `json:"description"`
			Since              string `json:"since"`
			DeprecatedSince    string `json:"deprecatedSince,omitempty"`
			Internal           bool   `json:"internal"`
			Post               bool   `json:"post"`
			HasResponseExample bool   `json:"hasResponseExample"`
			Changelog          []struct {
				Description string `json:"description"`
				Version     string `json:"version"`
			} `json:"changelog"`
			Params []struct {
				Key           string `json:"key"`
				Description   string `json:"description"`
				Required      bool   `json:"required"`
				Internal      bool   `json:"internal"`
				MaximumLength int    `json:"maximumLength,omitempty"`
				Since         string `json:"since,omitempty"`
			} `json:"params"`
		} `json:"actions"`
	} `json:"webServices"`
}

// try to catch the version
func fetchSonarVersion(base string) string {
	// default version
	var version string = "Unknowns Edition"
	var basenameURL string
	if string(base[len(base)-1:]) == "/" {
		basenameURL = base + "api/server/version"
	} else {
		basenameURL = base + "/api/server/version"
	}

	resp, err := http.Get(basenameURL)
	if err == nil && resp.StatusCode == 200 {
		defer resp.Body.Close()
		body, _ := io.ReadAll(resp.Body)
		version = string(body[:])
	} else {
		log.Debug("Retrieving version returned error: ", err)
	}
	log.Debug("Using version number: ", version)
	return version
}

func processSonarqubeOpenAPI(basenameOAS string, basenameV1 string) libopenapi.Document {
	// Try to read the V1 spec as a file
	rawData, err := os.ReadFile(basenameV1)
	if err != nil {
		// try to read the OAS as a link
		log.Debug("Error reading ", basenameV1, " as file .... trying as URL")
		var basenameURL string
		if string(basenameV1[len(basenameV1)-1:]) == "/" {
			basenameURL = basenameV1 + "api/webservices/list"
		} else {
			basenameURL = basenameV1 + "/api/webservices/list"
		}
		resp, err := http.Get(basenameURL)
		if err != nil {
			log.Fatal("Neither file nor url when fetching: ", basenameURL)
		} else {
			if resp.StatusCode == 200 {
				defer resp.Body.Close()
				var body []byte
				body, _ = io.ReadAll(resp.Body)
				rawData = body
				log.Info("Reading URL successfully, size ", len(rawData))
			} else {
				log.Fatal("Received status code: ", resp.StatusCode, " when fetching URL: ", basenameURL)
			}
		}
	} else {
		log.Info("Reading file successfully, size ", len(rawData))
	}
	// Try to read the OAS as a file
	log.Debug("Reading OAS data")
	rawDataOAS, err := os.ReadFile(basenameOAS)
	if err != nil {
		// try to read the OAS as a link
		log.Debug("Error reading ", basenameOAS, " as file .... trying as URL")
		var basenameURL string
		if string(basenameOAS[len(basenameOAS)-1:]) == "/" {
			basenameURL = basenameOAS + "api/v2/api-docs"
		} else {
			basenameURL = basenameOAS + "/api/v2/api-docs"
		}
		resp, err := http.Get(basenameURL)
		if err != nil {
			log.Fatal("Neither file nor url when fetching: ", basenameURL)
		} else {
			if resp.StatusCode == 200 {
				defer resp.Body.Close()
				var body []byte
				body, _ = io.ReadAll(resp.Body)
				rawDataOAS = body
				log.Debug("Reading : ", len(rawDataOAS))
			} else {
				log.Fatal("Received status code: ", resp.StatusCode, " when fetching URL: ", basenameURL)
			}
		}
	}
	log.Debug("Generating NewDocument from OAS data")
	document, err := libopenapi.NewDocument(rawDataOAS)
	if err != nil {
		log.Fatal(fmt.Sprintf("cannot create new document: %e", err))
	}
	v3Model, errors := document.BuildV3Model()
	v3Model.Model.Info.Version = fetchSonarVersion(basenameV1)
	if len(errors) > 0 {
		for i := range errors {
			log.Warning(fmt.Sprintf("error: %e\n", errors[i]))
		}
		log.Fatal(fmt.Sprintf("cannot create v3 model from document: %d errors reported",
			len(errors)))
	}

	// Reprocess the v3Model to rename all the path
	for apiPathName, _ := range v3Model.Model.Index.GetAllPaths() {
		// fmt.Println(i, j)
		path, ok := v3Model.Model.Paths.PathItems.Delete(apiPathName)
		if !ok {
			log.Debug("Path exist but not found: ", apiPathName)
		}
		operationPath := fmt.Sprintf("/v2%s", apiPathName)
		v3Model.Model.Paths.PathItems.Set(operationPath, path)
	}
	// Update servers considering new path
	// var newServers []*v3.Server
	for _, server := range v3Model.Model.Servers {
		url := strings.Replace(server.URL, "/api/v2", "", -1)
		server.URL = url
	}

	// Add a simple string schema for query params
	stringSchema := base.CreateSchemaProxy(&base.Schema{
		Type: []string{"string"},
	})

	// create an ordered property map
	propMap := orderedmap.New[string, *base.SchemaProxy]()

	// create a sample/empty schema that we can use in our document
	nothingSchema := base.CreateSchemaProxy(&base.Schema{
		Type:       []string{"object"},
		Properties: propMap,
	})

	// create response map
	responseMap := orderedmap.New[string, *v3.Response]()

	// OK response
	okResponseContentMap := orderedmap.New[string, *v3.MediaType]()
	okResponseContentMap.Set("application/json", &v3.MediaType{
		Schema: nothingSchema,
	})

	// add responses
	responseMap.Set("2XX", &v3.Response{
		Description: "Successful query.",
		Content:     okResponseContentMap,
	})

	var bodyContentMap AutoGenerated
	var wsActionPost string = "post"
	var operationDeprecated bool = true

	json.Unmarshal(rawData, &bodyContentMap)
	for _, webService := range bodyContentMap.WebServices {
		for _, wsAction := range webService.Actions {
			var operationParameters []*v3.Parameter
			for _, actionParam := range wsAction.Params {
				operationParameter := v3.Parameter{
					Description:     actionParam.Description,
					AllowEmptyValue: actionParam.Required,
					In:              "query",
					Required:        &actionParam.Required,
					Name:            actionParam.Key,
					Schema:          stringSchema,
				}
				operationParameters = append(operationParameters, &operationParameter)
			}
			extDoc := base.ExternalDoc{
				Description: "Sonarqube Documentation for " + wsAction.Key,
				URL:         fmt.Sprintf("https://next.sonarqube.com/sonarqube/web_api/api/%s/%s", webService.Path, wsAction.Key),
			}
			// var operationResponse v3.Response
			if wsAction.Post {
				wsActionPost = "get"
			} else {
				wsActionPost = "post"
			}
			if wsAction.DeprecatedSince == "" {
				operationDeprecated = false
			} else {
				operationDeprecated = true
			}

			operation := &v3.Operation{
				Description:  wsAction.Description,
				OperationId:  strings.Replace(fmt.Sprintf("v1_%s_%s_%s", wsActionPost, webService.Path, wsAction.Key), "/", "_", -1),
				Summary:      strings.Replace(wsAction.Key, "_", " ", -1),
				ExternalDocs: &extDoc,
				Parameters:   operationParameters,
				Deprecated:   &operationDeprecated,
				Responses: &v3.Responses{
					Codes: responseMap,
				},
			}
			operationPath := fmt.Sprintf("/%s/%s", webService.Path, wsAction.Key)
			var newPath *v3.PathItem
			if wsAction.Post {
				newPath = &v3.PathItem{
					Description: webService.Description,
					Post:        operation,
				}
			} else {
				newPath = &v3.PathItem{
					Description: webService.Description,
					Get:         operation,
				}
			}
			v3Model.Model.Paths.PathItems.Set(operationPath, newPath)
		}
	}
	log.Debug("Finished processing document.")
	return document
}

func main() {
	var inputV1Flag, inputV2Flag, outFile string
	var debug, urlFlagPublic, urlFlagDefault bool
	flag.BoolVar(&debug, "debug", false, "Debug")
	flag.StringVar(&inputV1Flag, "inputv1", "", "Name of the sonarqube webservices export file from /api/webservices/list or Sonarqube base URL.")
	flag.StringVar(&inputV2Flag, "inputv2", "", "Name of the sonarqube webservices export file from /api/v2/api-docs or Sonarqube base URL. (if missing we reuse the inputv1 value.)")
	flag.StringVar(&outFile, "outfile", "", "File base name to save to (extension will be added)")
	flag.BoolVar(&urlFlagDefault, "defaulturl", false, "Use http://localhost:9000/ for the url.")
	flag.BoolVar(&urlFlagPublic, "publicurl", false, "Use https://next.sonarqube.com/sonarqube/ for the url.")
	// flag.BoolVar(&jsonOutput, "json", false, "Generate JSON instead of YAML.")
	flag.Parse()

	if debug {
		log.SetLevel(log.DebugLevel)
	}
	if urlFlagDefault {
		inputV1Flag = "http://localhost:9000/"
		inputV2Flag = inputV1Flag
		log.Debug("Using ", inputV1Flag, " for inputV1 and inputV2")
	}
	if urlFlagPublic {
		inputV1Flag = "https://next.sonarqube.com/sonarqube/"
		inputV2Flag = inputV1Flag
		log.Debug("Using ", inputV1Flag, " for inputV1 and inputV2")
	}
	if inputV2Flag == "" {
		inputV2Flag = inputV1Flag
		log.Debug("Using ", inputV1Flag, " for inputV1 and inputV2")
	} else {
		log.Debug("Using ", inputV1Flag, " for inputV1 and ", inputV1Flag, " inputV2")
	}
	sonarqubeDocument := processSonarqubeOpenAPI(inputV2Flag, inputV1Flag)
	sonarqubeModel, errors := sonarqubeDocument.BuildV3Model()
	if len(errors) > 0 {
		for i := range errors {
			log.Debug(fmt.Sprintf("error: %e\n", errors[i]))
		}
		log.Fatal(fmt.Sprintf("cannot create v3 model from document: %d errors reported",
			len(errors)))
	}
	var renderDocument []byte
	log.Debug("Writing to file:", outFile)
	if outFile != "" {
		if strings.HasSuffix(strings.ToLower(outFile), "json") {
			renderDocument, _ = sonarqubeModel.Model.RenderJSON(" ")
		} else {
			renderDocument, _ = sonarqubeModel.Model.Render()
		}
		f, err := os.Create(outFile)
		if err != nil {
			log.Fatal("Issues when creating file: ", outFile)
		}
		defer f.Close()

		_, err = f.Write(renderDocument)
		if err != nil {
			log.Fatal("Error writing  file: ", err)
		}
		log.Info("Saving content to file: ", outFile)
	} else {
		renderDocument, _ = sonarqubeModel.Model.Render()
		fmt.Println(string(renderDocument))
	}
	os.Exit(0)
}
