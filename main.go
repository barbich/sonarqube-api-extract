package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"

	"net/http"
	"os"
	"strings"

	log "github.com/sirupsen/logrus"
	"github.com/swaggest/openapi-go/openapi3"
)

// Generic struct for sonarqube API calls, based on ingestion the sonarqube API list view output to https://mholt.github.io/json-to-go
type AutoGenerated struct {
	WebServices []struct {
		Path        string `json:"path"`
		Since       string `json:"since,omitempty"`
		Description string `json:"description,omitempty"`
		Actions     []struct {
			Key                string `json:"key"`
			Description        string `json:"description"`
			Since              string `json:"since"`
			DeprecatedSince    string `json:"deprecatedSince,omitempty"`
			Internal           bool   `json:"internal"`
			Post               bool   `json:"post"`
			HasResponseExample bool   `json:"hasResponseExample"`
			Changelog          []struct {
				Description string `json:"description"`
				Version     string `json:"version"`
			} `json:"changelog"`
			Params []struct {
				Key           string `json:"key"`
				Description   string `json:"description"`
				Required      bool   `json:"required"`
				Internal      bool   `json:"internal"`
				MaximumLength int    `json:"maximumLength,omitempty"`
				Since         string `json:"since,omitempty"`
			} `json:"params"`
		} `json:"actions"`
	} `json:"webServices"`
}

// try to catch the version
func fetchSonarVersion(base string) string {
	// default version
	var version string = "Unknowns Edition"

	resp, err := http.Get(strings.Replace(base, "api/webservices/list", "api/server/version", -1))
	if err == nil && resp.StatusCode == 200 {
		defer resp.Body.Close()
		body, _ := io.ReadAll(resp.Body)
		version = string(body[:])
	} else {
		log.Debug("Retrieving version returned error: ", err)
	}
	log.Debug("Using version number: ", version)
	return version
}

// Process a []byte flow as a sonarqube API definition and return a openapi3.reflector
func processSonarqubeWS(rawData []byte) openapi3.Reflector {
	var bodyContentMap AutoGenerated
	json.Unmarshal(rawData, &bodyContentMap)
	reflector := openapi3.Reflector{}
	reflector.Spec = &openapi3.Spec{Openapi: "3.0.3"}
	reflector.Spec.Info.
		WithTitle("Sonarqube OpenAPI specification").
		// WithVersion(versionSonar).
		WithDescription("Sonarqube Community Edition WebApi specifications.")
	defaultServer := openapi3.Server{
		URL: "https://next.sonarqube.com/sonarqube/",
	}
	reflector.Spec.Servers = append(reflector.Spec.Servers, defaultServer)
	for indexWS, webService := range bodyContentMap.WebServices {
		for indexAction, wsAction := range webService.Actions {
			var setMethod string

			if wsAction.Post {
				setMethod = http.MethodPost
			} else {
				setMethod = http.MethodGet
			}
			operationContext, _ := reflector.NewOperationContext(setMethod, fmt.Sprintf("/%s/%s", webService.Path, wsAction.Key))

			log.Debug(fmt.Sprintf("%d-%d: /%s/%s\n", indexWS, indexAction, webService.Path, wsAction.Key))
			operation := openapi3.Operation{}
			operationContext.SetDescription(wsAction.Description)
			if wsAction.DeprecatedSince == "" {
				operationContext.SetIsDeprecated(false)
			} else {
				operationContext.SetIsDeprecated(true)
			}
			operationContext.SetID(strings.Replace(fmt.Sprintf("%s_%s", webService.Path, wsAction.Key), "/", "_", -1))
			operationContext.SetSummary(strings.Replace(wsAction.Key, "_", " ", -1))
			allowEmptyValue := true
			for _, actionParam := range wsAction.Params {
				operationParameter := openapi3.Parameter{
					In:              "query",
					Name:            actionParam.Key,
					Description:     &actionParam.Description,
					AllowEmptyValue: &allowEmptyValue,
				}
				x := openapi3.SchemaTypeString
				openapiSchemaStringSchema := openapi3.Schema{
					Type: &x,
				}
				openapiSchemaString := openapi3.SchemaOrRef{
					Schema: &openapiSchemaStringSchema,
				}

				operationParameter.Schema = &openapiSchemaString

				operationParameterOrRef := openapi3.ParameterOrRef{
					Parameter: &operationParameter,
				}

				operation.Parameters = append(operation.Parameters, operationParameterOrRef)
			}

			operationResponse := operation.Responses.MapOfResponseOrRefValues["2XX"].Response
			if operationResponse == nil {
				operationResponse = &openapi3.Response{}
			}
			operationResponse.WithDescription("Response to " + wsAction.Key)

			openapiSchema := openapi3.SchemaOrRef{}
			operationResponse.WithContentItem("application/json", openapi3.MediaType{Schema: &openapiSchema})
			operation.Responses.WithMapOfResponseOrRefValuesItem("2XX", openapi3.ResponseOrRef{Response: operationResponse})

			reflector.Spec.AddOperation(setMethod, fmt.Sprintf("/%s/%s", webService.Path, wsAction.Key), operation)
		}
	}
	return reflector
}

func main() {
	var urlFlag, fileFlag, outFile string
	var debug, urlFlagPublic, urlFlagDefault bool
	flag.BoolVar(&debug, "debug", false, "Debug")
	flag.StringVar(&fileFlag, "file", "", "Name of the sonarqube webservices export from /api/webservices/list.")
	flag.StringVar(&urlFlag, "url", "", "Sonarqube URL to fetch the webservices list from (format http://localhost:9000/api/webservices/list).")
	flag.StringVar(&outFile, "outfile", "sonarqube-api", "File base name to save to (extension will be added)")
	flag.BoolVar(&urlFlagDefault, "defaulturl", false, "Use http://localhost:9000/api/webservices/list for the url.")
	flag.BoolVar(&urlFlagPublic, "publicurl", false, "Use https://next.sonarqube.com/sonarqube/api/webservices/list for the url.")
	flag.Parse()

	if debug {
		log.SetLevel(log.DebugLevel)
	}
	var rawData []byte
	var err error
	var resp *http.Response
	var versionSonar string = "Unknowns Edition"
	if urlFlagDefault {
		urlFlag = "http://localhost:9000/api/webservices/list"
	}
	if urlFlagPublic {
		urlFlag = "https://next.sonarqube.com/sonarqube/api/webservices/list"
	}
	if urlFlag != "" {
		log.Debug("Processing: ", urlFlag)
		var body []byte
		resp, err = http.Get(urlFlag)
		if err != nil {
			log.Fatal("Error reading URL: ", err)
		}
		log.Debug("Response return code: ", resp.StatusCode)
		if resp.StatusCode == 200 {
			defer resp.Body.Close()
			body, _ = io.ReadAll(resp.Body)
			rawData = body
			log.Debug("Reading : ", resp.ContentLength)
		} else {
			log.Fatal("Received status code: ", resp.StatusCode, " when fetching URL: ", urlFlag)
		}
		versionSonar = fetchSonarVersion(urlFlag)
	} else {
		rawData, err = os.ReadFile(fileFlag)
		if err != nil {
			log.Fatal("Error reading file.", err)
		}
	}

	reflector := processSonarqubeWS(rawData)
	reflector.Spec.Info.WithVersion(versionSonar)

	schema, err := reflector.Spec.MarshalYAML()
	if err != nil {
		log.Fatal("Could not convert the reflector to YAML: ", err)
	}
	yamlFile := fmt.Sprintf("%s.yaml", outFile)
	f, _ := os.Create(yamlFile)
	_, err = f.Write(schema)
	if err == nil {
		log.Info("Saving YAML file to: ", yamlFile)
	} else {
		log.Fatal("Error writing YAML file: ", err)
	}
	f.Close()

	schema, err = reflector.Spec.MarshalJSON()
	if err != nil {
		log.Fatal("Could not convert the reflector to JSON: ", err)
	}
	jsonFile := fmt.Sprintf("%s.json", outFile)
	f, _ = os.Create(jsonFile)
	_, err = f.Write(schema)
	if err == nil {
		log.Info("Saving JSON file to: ", jsonFile)
	} else {
		log.Fatal("Error writing JSON file: ", err)
	}
	f.Close()

	os.Exit(0)
}
